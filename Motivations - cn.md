## Motivations动机

大型分布式系统通常由不同的团队使用多种技术和编程语言以模块化的方式实现。分布式系统中的部件需要可靠的通信并支持快速、独立的演进。模块之间高效、可扩展的通信是分布式系统中的关键问题，会影响用户体验（时延）以及构建和运行系统需要的资源。

Reactive Manifesto中记录，Reactive Streams和Reactive Extensions类库中实现的架构模式不仅支持异步消息传递，并且包含请求/响应之外的通信模式。“RSocket”协议是包含“反应式”原理的正式通信协议。

以下是定义新协议的动机：

#### Message Driven消息驱动

网络通信是异步的。RSocket协议包含了这一点，并将所有通信建模为单个网络连接上的多路消息流，并且在等待响应时从不同步阻塞。

反应式宣言：

>Reactive Systems依靠异步消息传递来在组件之间建立边界，以确保松耦合，隔离，位置透明，并提供将错误委托为消息的方法。采用显式消息传递，可以通过对系统中的消息队列进行重塑和监视并在必要时施加背压来实现负载管理，弹性和流量控制。非阻塞通信允许接收者仅在活动时消耗资源，从而减少系统开销。

此外，HTTP/2的FAQ很好地解释了通过复用持久连接的形式采用面向消息的协议的动机：

> HTTP/1.x存在一个称为“行头阻塞”的问题，实际上一次只能在一个连接上处理一个请求。

> HTTP/1.1尝试通过pipeline解决这个问题，但是问题并没有得到完全解决（一个大或者慢的响应仍然会阻塞之后的响应）。此外，部署pipeline非常困难，因为许多中介和服务器无法正确处理pipeline。

> 这迫使客户使用多种试探法（通常是猜测法）来确定什么请求在什么时候对原点进行哪个连接；由于页面加载的可用连接数通常是10的倍数（或更多），因此会严重影响性能，通常会导致被阻止的请求“泛滥”。

> 复用通过允许同时发送多个请求和响应消息来解决这些问题。甚至有可能将一条消息的一部分与另一条消息混合在一起。

> 反过来，这允许客户端仅使用一个连接来加载页面。

再议持久化连接：

> 使用HTTP/1，浏览器在每个源之间打开四个到八个连接。 由于许多站点使用多个源，因此这可能意味着单个页面加载会打开三十多个连接。

> 一个应用程序同时打开如此多的连接打破建立许多TCP连接的假设。由于每个连接都会在响应中引发大量数据，因此中间网络中的缓冲区溢出是真正的风险，从而导致拥塞事件并重传。

> 此外，使用如此多的连接会不公平地垄断网络资源，将它们从其他性能更好的应用程序（例如VoIP）“窃取”。



#### Interaction Models互动模型

不恰当的协议会增加开发系统的成本。不恰当的协议可能是不匹配的抽象从而迫使系统设计使用协议允许的模式。使用不恰当的协议，开发人员将花费更多时间来解决其缺点，以处理错误并获得可接受的性能。在多语言环境中，问题会被放大，因为不同的语言将使用不同的方法来解决此问题，并且需要团队之间进行额外的协作。 迄今为止，事实上的标准是HTTP，所有内容都是请求/响应。 在某些情况下，这可能不是实现特定功能的理想通信模型。

推送通知就是一个例子。 使用请求/响应模式会强制应用程序执行轮询，在轮询过程中客户端会不断发送请求以检查服务器中的数据。 无需花太多时间就可以找到应用程序每秒执行大量请求并被告知没有任何客户端需要的内容的例子。 这对于客户端，服务器和网络都是浪费，要花钱，增加基础架构的大小，增加操作的复杂性，从而提高可用性。 通常，它还会增加接收通知的用户体验的等待时间，因为会使用更长的时间间隔轮询以降低成本。

由于这个和其他原因，RSocket不仅限于一个交互模型。下文描述的各种受支持的交互模型为系统设计打开了强大的新可能性：


##### Fire-and-Forget

Fire-and-forget是对请求/响应模式的一种优化，在不需要响应的时候更加有用。Fire-and-Forget通过跳过响应来减少对网络的使用量，客户端和服务器因为无需记录需要等待和关联响应或者取消请求从而节省了处理时间，带来了巨大的性能提升。

对于允许有损性的场景（例如非关键事件日志记录），此交互模型十分有用。

使用方法如下：

```java
Future<Void> completionSignalOfSend = socketClient.fireAndForget(message);
```

##### Request/Response (single-response)

仍支持标准请求/响应语义，并且仍有望代表RSocket连接上的大多数请求（多数使用场景）。这些请求/响应交互可以被视为优化的“仅1个响应的流”，并且是在单个连接上多路复用的异步消息。

使用者“等待”响应消息，因此它看起来像是典型的请求/响应，但在其下面永远不会同步阻塞。

使用方法如下：

```java
Future<Paload> response = socketClient.requestResponse(requestPayload);
```

##### Request/Stream (multi-response, finite) 

请求/流是对请求/响应的扩展，允许将多条消息以流的形式返回。可以将其视为“集合”或“列表”响应，但不是将所有数据作为单个响应获取，而是按顺序流回每个元素。

可能的使用场景如下:

- 获取电影列表
- 获取目录中的所有产品
- 按行读取文件

使用方式如下：

```java
Publisher<Payload> response = socketClient.requestStream(requestPayload);
```

##### Channel

通道是双向的，双向都有消息流。

受益于此交互模型的示例:

- 发生变化时服务端向客户端发送增量和差异。
- 客户端会随着时间的推移更新订阅，以添加/删除条件/主题/等

如果没有双向通道，客户端将不得不取消初始请求，重新请求并从头开始接收所有数据，而不仅仅是更新订阅并有效地获取差额。

使用方式如下:

```java
Publisher<Payload> output = socketClient.requestChannel(Publisher<Payload> input);
```

#### 行为

除了上面提到的交互模型，RSocket还有一些其他的行为可以帮助应用和系统提供效率。

##### 单响应 vs 多响应

单响应和多响应之间一个关键的不同是RSocket协议栈如何将数据发送到应用程序：单响应可能需要多个帧承载，科切可能是流式传输多个消息的较大RSocket的一部分。但是单响应意味着仅当收到整个响应时，应用程序才能获取其数据。多响应零散的传输数据，这可以使用户在设计服务时考虑到多响应，客户端可以在收到第一个数据块后立即开始处理数据。

##### 双向（双工）

RSocket支持双向请求，其中客户端和服务器都可以充当请求者或响应者。这允许客户端（例如用户设备）充当来自服务器的请求的响应者。

例如，服务器可以向客户端查询跟踪调试信息，状态等。通过允许服务器端在需要时进行查询，而不是让成千上万的客户端不断提交仅偶尔出现的数据，这可以减少基础结构扩展需求和被需要。 这也打开了客户端和服务器之间当前未想到的未来交互模型。

##### 取消

所有的流都支持取消以提高服务器清理资源的速度。这意味着当客户端取消或离开时，服务器将有机会提前终止工作。这对于诸如流和订阅之类的交互模型是必不可少的，但是对于请求/响应甚至是有用的，以允许有效地采用诸如“备份请求”之类的方法来驯服尾部延迟。


#### 可恢复性

对于长时间存活的流，特别是来自从移动客户端服务订阅的流，如果必须重新建立所有订阅，则网络断开连接会严重影响成本和性能。尤其在可以立即重新连接网络或在Wifi和蜂窝网络之间切换时，这一点尤为严重。

RSocket支持会话恢复，允许简单的握手即可通过新的传输连接恢复客户端/服务器会话。


#### 应用流控

RSocket支持两种应用级流控以保护客户端和服务器资源不会被耗尽。RSocket协议旨在用于数据中心、服务器到服务器以及服务器通过互联网到设备的场景。

##### 响应式流的request(n)异步拉取

应用流控的这种形式适用于服务器到服务器和服务器到设备的场景。这种流控方式受响应式流Subscription.request(n)的启发。RxJava、Reactor和Akka 实现了“异步拉取”形式的流控。

RSocket允许在请求者到响应者（通常是客户端到服务器）的网络边界上组成`request(n)` 信号。这可以在应用级使用响应式流的语义控制从响应者到请求者的流并允许使用有限缓冲区，因此可以根据应用程序的消费情况进行调整而不是仅仅依靠传输和网络缓冲区。

##### Leasing

流控的第二种形式主要关注数据中心中的服务器到服务器场景。启用该种形式的流控后，响应者（通常是服务器）可以基于其对请求者容量的了解，向请求者发出租约，以控制请求速率。在请求方，这可以实现应用程序级负载平衡，以便仅将消息发送给已发出信号容量的响应者（服务器）。从服务器到客户端的信号允许在具有机器集群的数据中心中使用更智能的路由和负载平衡算法。


#### 多语言支持

Many of the motivations above can be achieved by leveraging existing protocols, libraries, and techniques. However, this often ends up being tightly coupled with specific implementations that must be agreed upon across languages, platforms and tech stacks. Formalizing the interaction models and flow control behaviors into a protocol provides a contract between implementations in different languages. This in turn improves polyglot interactions in a broader set of behaviors than the ubiquitous HTTP/1.1 request/response, while also enabling Reactive Streams application level flow control across languages (rather than just in Java for example where Reactive Streams was originally defined).

上面提到的很多动机都可以使用现有的协议、库和技术实现。但是，这通常最终与必须跨语言，平台和技术堆栈达成一致的特定实现紧密结合。将交互模型和流控制行为形式化为协议，可以实现不同语言的实现之间的契约。反过来，与无处不在的HTTP / 1.1请求/响应相比，这可以改善行为集中的多语言交互，同时还支持跨语言的Reactive Streams应用程序级流控制（而不是仅在最初定义Reactive Streams的Java中）。

#### 灵活的传输层

像HTTP 请求/响应不是应用程序之间通信的唯一可以或必须使用的方式，TCP不是唯一可用的传输层，也不是所有使用场景下的最优选择。因此RSocket允许根据运行环境、设备能力以及性能需求切换传输层协议。RSocket目前支持的传输层协议包括WebSocket、TCP和Aeron，并且有望支持所有具有TCP特性的所有传输层协议比如Quic。

也许更重要的是RSocket无需花费巨大的精力就可以使用WebSocket、TCP和Aeron。例如，使用WebSocket通常十分很吸引人，但是WebSocket只暴露了框架语义，因此使用WebSocket需要定义应用层协议。定义应用层协议通常很复杂而且需要大量的精力投入。TCP甚至连框架都没有提供。因此，大多数应用程序最终使用HTTP / 1.1并坚持使用请求/响应模式，为此错过了交互模型比同步请求/响应带来的好处。

因此，RSocket基于网络传输定义了应用程序层语义，以允许在传输层协议可用时选择使用。本文档的后面部分是与其他协议的简要比较，这些协议在试图确定是否需要新的应用程序协议之前尝试利用WebSockets和Aeron。

#### 效率和性能

网络资源使用率低（重复握手、建链、拆链，膨胀的消息格式等）的协议会大大增加系统的延迟。同样，如果没有流控语义，当相关服务速度变慢时，单个编写不当的模块可能会使系统的其余部分超负荷运行，从而可能导致重试风暴，从而给系统带来进一步的压力。Hystrix是一个尝试解决同步请求/响应的解决方案，但是需要付出一定的代驾：额外的开销和复杂性。

此外，选择不当的通信协议会浪费服务器资源（CPU、内存、网络带宽）。尽快资源的浪费可以在较小的部署场景被接受，但是对于成百上千节点的大型系统微小的低效率会被放大的十分明显。尽快服务器资源相对便宜，但是也并不是无限的，但是运行服务器的空间难以扩展（地大才是王道）。即使使用好的工具，管理大型集群的成本也要高得多，灵活性也要低得多。常常被遗忘的是，集群越大，它的操作越复杂，这成为可用性问题。

RSocket致力于解决以下问题：

- 降低时延，提供系统效率。RSocket支持非阻塞、双工、应用层异步通信，流控。
- Reduce hardware footprint (and thus cost and operational complexity) by:
  - increasing CPU and memory efficiency through use of binary encoding
  - avoid redundant work by allowing persistent connections
- 减少硬件占用空间（降低成本和操作复杂性）：
  * 通过二进制编码提供CPU和内存的使用率。
  * 通过持久连接减少重复工作
- Reduce perceived user latency by:
- 减少用户感知时延：
  - 避免握手和相关的往返网络开销
  - 通过使用二进制编码减少计算时间
  - 分配更少的内存并降低垃圾回收成本


## 比较

下面是在决定创建RSocket协议之前对其他协议的简单回顾。它并不试图详尽无遗。它也不会试图批评各种协议，因为它们都擅长于其构建目的。本部分仅用于表达现有协议不能充分满足促使创建RSocket的要求。

- 按照OSI分层模型RSocket工作在5/6层，或者TCP/IP协议的应用层。
- RSocket协议旨在使用类似TCP的双工二进制传输协议作为传输层协议。

#### TCP & QUIC

没有框架或应用层语义，必须提供一个应用层协议。

#### WebSockets

提供了框架但是没有应用层语义，需要提供一个应用层协议。

#### HTTP/1.1 & HTTP/2

HTTP几乎不能为构建应用层协议提供足够的原始功能，但是仍然需要在其上构建应用层协议。HTTP不足以定义应用层语义（Google的GRPC是一个构建于HTTP/2协议之上的例子）。

这些有限的应用程序语义通常需要应用程序协议来定义诸如以下内容：
  - 请求使用GET，POST或者PUT
  - 使用Normal，Chunked或SSE进行响应
  - MimiType负载
  - 错误信息伴随标准的状态码
  - 客户端必须处理状态码
  - 使用SSE作为从服务器到客户端的持久通道，以允许服务器向客户端发出请求

没有从响应者（通常是服务器）到请求者（客户端）的流控机制。HTTP/2提供了字节级别的流控而不是应用级别流控。用于传递请求者可用性的机制效率低下而且令人痛苦。HTTP/2没有提供诸如fire-and-forget的交互模型，stream模型不够高效。

REST无处不在，但是仅有REST足以定义应用层语义。

HTTP/2怎么样呢？有木有解决HTTP/1的问题并消磨创建RSocket的动机？

很不幸的是不行。HTTP/2对于浏览器和请求/响应模式的文档传输而然更好，但是HTTP/2没有提供前文描述的应用需要的行为和交互模型。对于文档交互HTTP/2比HTTP/1做的更加优秀，但是对于应用而言我们可以而且理应做的比HTTP/2更加优秀。
